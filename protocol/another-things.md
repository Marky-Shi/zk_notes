# R1CS 与 Plonkish 约束系统比较

## 1. 基本定义

### R1CS (Rank-1 Constraint System)

R1CS 是零知识证明系统中表示计算约束的经典方式，将现实问题转换为一系列的线性约束。每个约束表示为：

$$a(x) \cdot b(x) = c(x)$$

其中：$a(x)$、$b(x)$、$c(x)$ 是变量的向量函数，表示这个约束的左右输入以及输出。这种表示方式可以用于验证某个计算是否正确执行，而无需知道输入的具体值。通过多个这样的约束，R1CS 能够定义任意代数电路的行为。

### Plonkish

Plonkish 是以 **PLONK** (Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge) 为代表的一类零知识证明系统中的约束描述方式，广义上称为 **Arithmetic Intermediate Representation (AIR)** 或 **PLONK-like constraints**。

Plonkish 的约束形式基于多项式，支持：

* 范围证明（Range proofs）
* 轨迹多项式（Trace polynomials）
* 自定义门（Custom gates）
* 查找表（Lookup tables）

Plonkish 使用多项式承诺来验证约束关系，能够更高效地支持更复杂的代数逻辑。

## 2. 表达能力比较

### R1CS

* **结构化强**：R1CS 强调通过线性组合来构造约束，结构严格且明确。
* **低灵活性**：仅适用于线性约束（乘积后相等），复杂操作（如非线性函数）需要通过手动分解转化为基本线性操作，导致电路较大。
* **电路等价性**：R1CS 表达的每个约束直接对应电路的一个节点或操作。

### Plonkish

* **灵活性高**：支持任意多项式约束，无需严格限制为线性乘积。
* **更紧凑的约束**：Plonkish 可以利用多项式分段表达复杂逻辑，减少约束总数。
* **自定义门支持**：可以定义特殊用途的门，直接支持复杂操作，如范围检查、位操作等。

## 3. 工作机制

### R1CS

* 将问题分解为基本的线性约束，每个约束都必须得到满足，且需要单独验证。
* 使用 **QAP (Quadratic Arithmetic Program)** 将 R1CS 转化为用于证明的多项式表示。
* 证明过程需要对每个变量及约束单独计算。
* 通常与椭圆曲线配对技术结合使用，如在Groth16等协议中。

### Plonkish

* 使用多项式承诺系统（如 Kate 承诺）来压缩和验证约束。
* 约束通过多项式的根性验证（即证明多项式在某些点上的值符合约束条件）。
* 支持批处理验证，可以同时验证多个约束，提高效率。
* 使用置换论证（permutation arguments）确保变量在不同约束间的一致性。

## 4. 具体例子比较

### 示例：计算 z = x³ + y

#### R1CS 表示
需要引入中间变量：
1. t₁ = x · x （计算x²）
2. t₂ = t₁ · x （计算x³）
3. z = t₂ + y （最终结果）

这需要3个约束：
- a₁ · b₁ = c₁ 其中 a₁=[x], b₁=[x], c₁=[t₁]
- a₂ · b₂ = c₂ 其中 a₂=[t₁], b₂=[x], c₂=[t₂]
- a₃ · b₃ = c₃ 其中 a₃=[t₂,y], b₃=[1,1], c₃=[z]

#### Plonkish 表示
可以直接表达为一个自定义门：
- q(x, y, z) = z - (x³ + y)

只需要1个约束，大大简化了表示。

## 5. 应用场景与性能比较

### 应用场景

**R1CS 适合：**
- 传统的zk-SNARK系统（如Groth16）
- 结构简单、固定的电路
- 需要极小证明大小的应用

**Plonkish 适合：**
- 需要灵活性的应用场景
- 复杂的密码学原语实现
- 需要支持通用SRS的系统
- 需要递归证明的应用

### 性能比较

| 特性 | R1CS | Plonkish |
|------|------|----------|
| 证明大小 | 小（固定大小） | 中等（与约束数量成对数关系） |
| 证明生成时间 | 慢（与约束数量成线性关系） | 中等（优化后可接近线性） |
| 验证时间 | 非常快（常数时间） | 快（常数时间） |
| 设置要求 | 电路特定的可信设置 | 通用可信设置（可更新） |
| 约束表达效率 | 低（需要多个约束表示复杂操作） | 高（可直接表达复杂操作） |
| 实现复杂度 | 中等 | 高 |

## 6. 发展趋势

### R1CS 的发展
- 优化约束生成，减少约束数量
- 改进QAP构造，提高效率
- 与其他系统的混合使用

### Plonkish 的发展
- 更高效的多项式承诺方案
- 更丰富的自定义门类型
- 查找表和其他优化技术的应用
- 支持更复杂的计算模型

## 7. 总结

R1CS 和 Plonkish 代表了零知识证明系统中两代约束表示方法：

- **R1CS** 是第一代成熟的约束系统，结构严格但灵活性有限，适合简单电路和需要极小证明的场景。
- **Plonkish** 是新一代约束系统，提供了更高的灵活性和表达能力，适合复杂应用和需要通用设置的场景。

随着零知识证明技术的发展，两种系统可能会继续共存，并在各自擅长的领域发挥作用，同时也会出现结合两者优点的混合系统。





