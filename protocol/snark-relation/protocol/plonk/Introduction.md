## Plonk

[plonk](https://medium.com/coinmonks/under-the-hood-of-zksnarks-plonk-protocol-part-2-ee00d6accb4d) 

属于SNARK 的零知识证明系统之一

`PLONK 具有通用且可更新的可信设置等优势。在 Groth16 中，需要特定于电路（或特定于任务，对于那些不熟悉该术语的人）的可信设置，而在 Plonk 中，相同的设置可以重复用于任何电路。“可更新”一词是指任何人都可以为设置添加随机性，从而增强对其完整性的信任。`

但是 PLONK 会导致**更大的证明**，从而会影响gas成本。

整个PlonK协议基于**多项式承诺**以及Fiat-Shamir启发式算法。给定3n个witness，并且给定多项式的门系数向量以及置换函数，证明每个门的约束成立

PlonK协议**公开的信息**，包括**门的系数，置换函数，以及公开输入**。

> PlonK算法实现了**Universal的零知识证明**。SRS只需要提供比多项式阶高的**可信设置**即可。PlonK电路采用特殊描述，一**个门只支持乘法和加法操作**。**电路需要证明门的输入输出满足外，还需要证明连线的连接关系**。PlonK算法的底层原理是**多项式承诺**。PlonK算法巧妙地将电路的满足关系通过**多项式承诺进行证明并验证。**



### 多项式

多项式是零知识证明系统的基本元素之一。

**多项式提供了一种形式，允许我们将特定过程的状态封装在单个函数中**。当要证明某些事情时，例如程序执行的正确性或语句的验证，我们可以使用多项式来表示这些过程。这一显着的特性使我们能够构建复杂的证明系统。



### KZG/Kate 多项式承诺模式

Plonk 利用 KZG（Kate、Zaverucha、Goldberg）方案进行验证。

在KZG承诺方案中，证明者承诺多项式（例如，表示程序执行的正确性）。

- 证明者通过向验证者发送承诺来承诺多项式。
- 作为回报，证明者收到验证者选择的随机值*r 。*
- 根据这个随机值*r*，证明者生成下一个承诺并将其发送回验证者。
- 然后，验证者根据从证明者收到的所有信息和随机值*r*检查证明者是否提供了正确的承诺。

```
得益于 PLONK 中的 Fiat-Shamir 启发式，KZG 变得非交互式，这意味着证明是发送给验证者的唯一数据。证明者和验证者都能够在没有任何交互的情况下就随机值r达成一致。这是使用哈希函数实现的：

证明者生成对多项式的承诺，例如用字母 C 表示。
为了获得随机值r，证明者使用哈希函数H，其中r = H ( C ) ，并使用值r生成剩余承诺Q，并将C和Q发送给验证者。
验证者使用相同的哈希函数H生成值r = H ( C ) ，并且拥有所有必要的数据，能够验证承诺C。
```

### Bathed Polynomial Commitment Schema

在 PLONK 中，证明者不仅需要承诺一个多项式，而且还需要承诺多个多项式。允许在一个步骤中提交多个多项式。使用称为线性独立的方法可以实现这一点。



`平均而言，zk-SNARK 程序可能需要 100 万个步骤（门）才能生成证明。因此，对于证明者来说，构建和使用如此冗长的多项式，将对证明者的性能产生重大影响，例如 ( *x* -1)( *x* -2)…( *x* -1000000) 等多项式。Groth16 协议正是这样做的。另一方面，PLONK 使用乘法子群，它也是建立在单位根上的。`

### Plonk 和 groth16 的区别

是两种用于零知识证明的算法，它们在构建约束、证明生成和验证阶段上有一些区别。

- 约束构建：
  - Plonk 和 groth16  都将问题约束成一组数学表达式，但
    - **PLONK** 使用门约束和线约束，将问题描述等价于约束描述。
    - Groth16  使用非通用可信设置，构建一个配对验证等式
- 证明生成
  - groth16 的证明规模较小，但依赖于非通用可信设置
  - Plonk 证明验证更加复杂，但基于通用可信设置
- 验证阶段
  - Groth 16 验证性能较好，但需要三次配对操作
  - plonk的验证更加复杂，但使用了Kate承诺来保护隐私信息。
- 与R1CS比较
  - 在Plonk中，每个电路限制式只能有一个加法或者乘法，而在R1CS里，虽然每一个电路只能有一个乘法运算，但是可以有无限加法运算。这也使得Plonk的电路比Groth16电路大得多。但Plonk可以使用**custom gate** 使得电路的弹性很大。


总之，Groth16 在证明的工作量和证明长度上仍然保持着最有性能，而Plonk 在SRS 长度方面表现出色



一些加速的心得



>1. 对重计算任务的硬件加速 (**Hardware acceleration**) 我们已经看到，如 MSM（多项式标量乘法），FFT（快速傅里叶变换），和 iFFT（逆快速傅里叶变换）等重计算在证明生成所需的总计算中占了很大一部分。这些算法在 CPU 上运行通常相当缓慢，可以通过在 GPU，FPGA 或 ASIC 上运行来大大加速。
>2. 减少 trace table 中的行数 我们还看到，几乎所有涉及证明生成的计算都与 *n* (即 trace table 行数) 成比例增长（也被称为“门的数量” ）。如何在使用最少行数的同时表示某些复杂计算，是一个具有重大效率影响的研究领域。
>3. **Parallelize and pipeline**
>
>许多证明系统，包括我们在这里研究的系统，都有自然的并行化机会。例如，在第二阶段的列承诺步骤中，每列的承诺都可以并行计算。更进一步，每个见证列的承诺 `MSM` 可以与其生成同时并行计算。并行化和流水线化计算可以显著加快整个过程。
>
>1. **Alternative proof systems**



$$

\text{Left Input (L)} \cdot \text{Right Input (R)} = \text{Output (O)}.
$$
