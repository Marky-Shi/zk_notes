# PLONK: 高效通用零知识证明系统

PLONK（Permutations over Lagrange-bases for Oecumenical Noninteractive Arguments of Knowledge）是一个通用的零知识证明协议，支持任意电路的高效证明和验证。其核心思想是将计算约束表达为多项式关系，并通过多项式承诺和验证机制来实现高效的证明和验证过程。

## 1. 基本概念与架构

### 1.1 核心思想

在PLONK中，输入和输出被表示为拉格朗日基（Lagrange basis），并通过置换技术构建证明。具体来说，电路的输入和输出首先映射到拉格朗日基上，然后利用置换和多项式承诺来生成和验证证明。

### 1.2 PLONK与R1CS的区别

PLONK 不直接使用 R1CS，而是使用自定义门（custom gates）和线（wires）来表示电路。这种方法提供了更大的灵活性和更高的效率：

- **R1CS**: 每个约束表示为 $A \cdot B = C$ 形式
- **PLONK**: 支持自定义门，可以表达更复杂的约束关系

### 1.3 PLONK的主要组件

1. **自定义门**: 支持各种算术和逻辑操作
2. **置换约束**: 确保变量在不同位置的一致性
3. **多项式承诺**: 高效地承诺和验证多项式
4. **零知识性**: 通过盲化技术保证隐私

## 2. 电路表示与多项式编码

### 2.1 电路表示为门和线

PLONK 使用自定义门和线来表示电路。每个门执行一个简单的算术运算（加法或乘法）。线连接不同的门，表示变量的传递。

以验证 $X \cdot Y = Z$ 为例，基本约束可表示为：

$${Left Input (L)} \cdot \text{Right Input (R)} = \text{Output (O)}.\\
A \cdot B - C = 0,\\
A = x ,  B = y ,  C = z 
$$ 

### 2.2 自定义门的灵活性

PLONK 支持自定义门，例如范围检查门 $x \in [0, r)$ 可通过以下多项式约束实现：

$$Q(x) = \prod_{i=0}^{r-1} (x - i)$$

这允许更灵活的电路建模，同时减少门的数量。

### 2.3 多项式表示

将电路门/线转为有限域上的多项式关系是PLONK的核心步骤：

1. **拉格朗日插值**：将离散的电路约束点转化为多项式 $Q(x)$
2. **约束多项式**：对于 $x \cdot y = z$，对应的约束多项式为：$Q(x) = A(x) \cdot B(x) - C(x)$
3. **验证目标**：证明 $Q(x) \equiv 0 \pmod{Z_H(x)}$，其中 $Z_H(x)$ 是拉格朗日基的零点多项式

> **零化多项式** $Z_H(X)$ 定义为其根为集合 H 中所有元素的最小次多项式：
> $$Z_H(X) = \prod_{i \in H} (X - i)$$
> 
> 如果 $Q(X)$ 在 H 上的所有点都是零点，那么 $Q(X)$ 可以被 $Z_H(X)$ 整除，即存在一个商多项式 $T(X)$，使得：
> $$Q(X) = T(X) \cdot Z_H(X)$$

### 2.4 拉格朗日基多项式

假设电路有 n 个门，门的索引集合为 H = {0, 1, ..., n-1}。第 i 个门的拉格朗日基多项式 $L_i(X)$ 定义为：

$$ L_i(X) = \prod_{j \in H, j \ne i} \frac{X - j}{i - j}$$

$L_i(X)$ 的特点是：当 X = i 时，$L_i(X) = 1$；当 X ≠ i 且 X ∈ H 时，$L_i(X) = 0$。

### 2.5 线多项式

对于每条线（wire）w（例如 X, Y, Z），我们定义一个多项式 W(X)，使得 W(X) 等于第 i 个门在线 w 上的取值。

对于我们的例子 $x \cdot y = z$ 来说，该电路只有一个门，于是有：
A(X) = 3 · $L_0(X)$ = 3, B(X) = 5 · $L_0(X)$ = 5, C(X) = 15 · $L_0(X)$ = 15.

## 3. 复制约束与置换约束

### 3.1 复制约束（Copy Constraints）

复制约束用于确保同一个变量在不同地方取值一致。定义一个置换 σ，它描述了哪些线应该具有相同的值。

### 3.2 置换约束（Permutation Argument）

PLONK 使用置换多项式确保电路变量的连通性和一致性。它验证变量是否在电路的约束关系中被正确匹配。

PLONK 使用三个置换：
- σ<sub>wire</sub>：连接同一门内的线
- σ<sub>copy</sub>：连接需要复制的线
- σ<sub>id</sub>：恒等置换

### 3.3 置换约束公式

使用置换多项式 $\sigma(x)$，验证输入变量的排列是否满足约束：

$$\prod_{i=1}^n (x_i - \sigma(x_i)) = 0$$

对于 $x \cdot y = z$，置换多项式验证 $A(x), B(x), C(x)$ 是否满足正确的连通性。

### 3.4 置换多项式的递归关系

PLONK 使用了递归式置换：

$$ Z(X) \cdot (L_0(X) + \beta + \gamma) = Z(X \cdot \omega) \cdot (A(X) + \beta \cdot \sigma(X) + \gamma) $$

其中：
- $\omega$ 是域上的 n 次单位根
- $L_0(X)$：第一个门的拉格朗日基多项式
- $\sigma(X)$：置换多项式，定义了线之间的连接关系
- $A(X)$：电路中一条线（例如输入线）的多项式表示
- $\beta, \gamma$：由验证者随机选择的两个值（通过 Fiat-Shamir 变换获得）

## 4. 多项式承诺与验证

### 4.1 多项式承诺

证明者通过多项式承诺机制（如 Kate 承诺）提交多项式 $A(x), B(x), C(x), Q(x)$ 的承诺。

承诺公式：$[P(X)]_1 = P(s) \cdot g_1$，其中 s 是一个秘密点（来自 CRS），$g_1$ 是椭圆曲线群 $G_1$ 的生成元。

### 4.2 检查多项式约束的零点

通过随机验证点 $\gamma$，验证约束多项式在 $Z_H(\gamma) = 0$ 时是否成立。

随机点检查：验证以下条件
$$Q(\gamma) = A(\gamma) \cdot B(\gamma) - C(\gamma) \stackrel{?}{=} 0$$

如果成立，则证明 $x \cdot y = z$ 约束成立。

### 4.3 零知识性

PLONK 使用盲化多项式（Blind Polynomial）增强零知识性，在承诺时加入随机性 $\gamma$，以隐藏具体输入数据。

盲化公式：承诺多项式加入随机 $\gamma$
$${Com}(P) = g^{P(s) + \gamma}$$ 

验证时，这种随机性不会影响正确性，但能有效隐藏原始输入。

### 4.4 验证多项式分式

PLONK 将约束多项式验证转化为分式多项式的检查。对于 $x \cdot y = z$：
$$Q(x) / Z_H(x) \stackrel{?}{=} 0$$  

证明者提供 $Q(x)$ 的承诺，验证者通过随机采样 $\gamma$ 验证分式关系。

换句话说：$[Q(\tau)]_1 = [T(\tau)]_1 \cdot [Z_H(\tau)]_1$

其中 $\tau$ 是一个随机点，$Q(X)$ 是门约束多项式，$Z_H(X)$ 是零化多项式，$T(X)$ 是商多项式。

## 5. Fiat-Shamir变换与随机点选择

随机点 $\gamma$ 通常是使用 Fiat-Shamir 变换（将交互式协议转化为非交互式协议）生成的。具体来说：

1. **证明者生成承诺**：证明者提交多项式的承诺，例如 $A(x), B(x), C(x)$ 等

2. **构造随机点**：验证者基于承诺计算随机点 $\gamma$。为了确保随机性和不可预测性，随机点的选取基于哈希函数：
   $$\gamma = \text{Hash}(\text{Com}(A), \text{Com}(B), \text{Com}(C), \dots)$$ 
   
   其中 $\text{Com}(A), \text{Com}(B), \dots$ 是多项式的承诺。

### 5.1 随机点的作用

1. **用于分式多项式验证**：在 PLONK 中，所有的约束验证都被归约到分式多项式的验证：
   $$Q(x) / Z_H(x)$$
   其中 $x = \gamma$。通过随机点 $\gamma$ 的选取，验证者只需验证约束在单一随机点是否成立，而无需检查整个域上的所有点。

2. **防止多项式伪造**：
   随机点 $\gamma$ 确保证明者无法通过伪造多项式 $Q(x)$ 来欺骗验证者。例如，若验证仅在固定点进行，证明者可能构造一个伪造多项式 $Q'(x)$ 满足验证点，但实际不符合约束。随机点的引入增加了欺骗的难度。

## 6. PLONK 验证流程总结

### 6.1 验证 $x \cdot y = z$ 的过程

1. **定义约束**：将 $x \cdot y = z$ 表示为多项式 $Q(x) = A(x) \cdot B(x) - C(x)$
2. **承诺多项式**：提交 $A(x), B(x), C(x), Q(x)$ 的承诺
3. **验证置换**：检查输入变量的排列是否满足约束
4. **零点检查**：验证 $Q(x) \equiv 0 \pmod{Z_H(x)}$
5. **随机点验证**：验证 $Q(\gamma) = 0$ 是否成立

### 6.2 PLONK 的公式总结

1. **约束多项式**：
   $$Q(x) = A(x) \cdot B(x) - C(x)$$

2. **置换约束**：
   $$\prod_{i=1}^n (x_i - \sigma(x_i)) = 0$$

3. **零知识盲化**：
   $${Com}(P) = g^{P(s) + \gamma}$$

4. **分式验证**：
   $$Q(x) / Z_H(x) \stackrel{?}{=} 0$$

## 7. PLONK的优势与应用

### 7.1 PLONK的主要优势

- **通用性**：支持任意算术电路
- **效率**：证明规模线性增长，验证时间近乎恒定
- **可更新性**：支持通用参考字符串(SRS)的更新
- **可组合性**：支持递归证明和证明聚合
- **灵活性**：支持自定义门和
