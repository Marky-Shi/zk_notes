# Groth16

## 1. 概述

Groth16 是一种高效的零知识简洁非交互知识证明（zk-SNARKs）协议，由 Jens Groth 在 2016 年提出。它是目前实际应用中最广泛使用的 zk-SNARK 协议之一，因其证明大小小、验证速度快和计算效率高而受到青睐。

### 1.1 主要特点

- **简洁性**：生成的证明只有 3 个群元素，是目前最小的 zk-SNARK 证明之一
- **高效验证**：验证只需要执行少量的配对运算，速度非常快
- **可信设置**：需要一个可信的初始设置阶段（trusted setup）
- **完美零知识**：在随机预言机模型下提供完美的零知识性

### 1.2 应用场景

- **区块链隐私交易**：如 Zcash 的 Sapling 升级
- **可验证计算**：外包计算的正确性验证
- **隐私保护的身份验证**：证明身份属性而不泄露具体信息
- **智能合约隐私**：保护链上交易的隐私

## 2. Groth16 协议流程

Groth16 协议包含以下主要步骤：

1. **电路描述**：将计算问题转化为电路表示
2. **QAP 转化**：将电路转换为多项式形式
3. **Setup 计算**：生成公共参数
4. **Prove 计算**：生成零知识证明
5. **Verify 计算**：验证证明的有效性

### 2.1 电路描述

1. 所有电路都有一个专业术语 Relation（变量之间的关系描述）
2. 电路通常使用 R1CS (Rank-1 Constraint System) 语言进行描述，类似于线性方程组
3. 需要将 R1CS 描述的电路转换为 QAP (Quadratic Arithmetic Program)

### 2.2 QAP 转化

1. 在 R1CS 和 QAP 之间的转化称为 Reduction
2. QAP 描述使用**拉格朗日基函数**，而不是多项式系数，以更好地适应 Groth16 算法的要求
3. 这种转换使得约束检查可以通过多项式运算高效完成

### 2.3 Domain 选择

1. 选择合适的 domain (域) 对计算性能至关重要
2. domain 的选择影响拉格朗日插值和 **FFT/iFFT** 的计算
3. 不同的 domain 适用于不同的输入个数
4. 通常选择支持快速傅里叶变换的域，如包含单位根的域

### 2.4 Setup 计算

1. 生成证明密钥（PK）和验证密钥（VK）
2. 这一步需要可信第三方执行，是 Groth16 的"可信设置"阶段
3. 设置完成后，生成的参数可以被多次使用

### 2.5 Prove 计算

1. 在给定 **witness** 或 **statement** 的情况下，生成证明
2. 涉及多次 FFT/iFFT 计算和 MultiExp（多点乘法）操作
3. 生成的证明包含三个群元素

### 2.6 Verify 计算

1. 在已知证明和验证密钥的情况下，通过配对函数验证证明的正确性
2. 验证过程计算量小，效率高

## 3. 数学基础

### 3.1 椭圆曲线和双线性配对

#### 基本设置

选择一个椭圆曲线 $E$ 及其循环群 $G_1$、$G_2$、$G_T$，具有素数阶 $p$。

选取随机生成元 $g_1 \in G_1$、$g_2 \in G_2$（为简化表示，后文中用 $g$ 表示 $g_1$，用 $h$ 表示 $g_2$）

选择双线性配对 $e: G_1 \times G_2 \to G_T$

配对的性质：$e(g_1^a, g_2^b) = e(g_1, g_2)^{ab}$

#### 公共参考字符串（CRS）

* **证明密钥**：
  $Pk = \{g^\alpha, g^\beta, g^\delta, \{g^{a_i(\tau)}, g^{\beta a_i(\tau)}, h^{b_i(\tau)}, g^{c_i(\tau)}\}_{i \in [m]}, \{g^{\tau^i}\}_{i \in [d]}\}$
  
  包含多项式评估和随机数相关的值。

* **验证密钥**：
  $Vk = \{g^\gamma, h^\beta, h^\gamma, e(g^\alpha, h^\beta), \{h^{\tau^i}\}_{i \in [d]}\}$
  
  包含验证需要的常数，如 $e(g^\alpha, h^\beta)$。

其中 $m$ 是约束数量，$d$ 是多项式的阶数，$\tau, \alpha, \beta, \gamma, \delta$ 是随机选择的值。

### 3.2 R1CS (Rank-1 Constraint System)

R1CS 将计算分解成一系列形如 $(a \cdot w) \cdot (b \cdot w) = (c \cdot w)$ 的约束。

这里的 $w$ 是 witness 向量，包含所有变量，包括：

* 常量（通常为 1，表示偏移量）
* 输入变量
* 中间变量
* 输出变量

#### 示例：乘法约束

对于 $z = x \cdot y$，R1CS 的表示：

$$
w = \begin{pmatrix} 1 \\ x \\ y \\ z \end{pmatrix}, \quad
a = \begin{pmatrix} 0 \\ 1 \\ 0 \\ 0 \end{pmatrix}, \quad
b = \begin{pmatrix} 0 \\ 0 \\ 1 \\ 0 \end{pmatrix}, \quad
c = \begin{pmatrix} 0 \\ 0 \\ 0 \\ 1 \end{pmatrix}
$$

约束等式为：$(a \cdot w) \cdot (b \cdot w) = (c \cdot w) \implies x \cdot y = z$

#### 复杂计算的约束

对于更复杂的计算，例如 $z = x^2 + y$，需要多个约束：

1. 引入中间变量 $t = x^2$
2. 第一个约束：$x \cdot x = t$
3. 第二个约束：$t + y = z$（加法约束可以通过适当设置 $a$, $b$, $c$ 向量实现）

R1CS 生成形如 $n \times m$ 格式的矩阵，其中 $n$ 行是约束的数量，$m$ 列是 witness 的数量。

### 3.3 QAP (Quadratic Arithmetic Program)

QAP 将 R1CS 转换为多项式形式，使得约束检查可以通过多项式运算高效完成。

#### 多项式定义

对于每个约束 $i$，定义多项式 $a_i(x)$, $b_i(x)$, $c_i(x)$，它们的值满足：

$$a_i(r_j) = A_{j,i}, \quad b_i(r_j) = B_{j,i}, \quad c_i(r_j) = C_{j,i}$$

其中 $r_j$ 是第 $j$ 个约束的评估点，$A_{j,i}$, $B_{j,i}$, $C_{j,i}$ 是 R1CS 矩阵中的元素。

#### 全局多项式

全局多项式表示为：

$$
A(x) = \sum_{i=1}^{m} w_i \cdot a_i(x), \quad
B(x) = \sum_{i=1}^{m} w_i \cdot b_i(x), \quad
C(x) = \sum_{i=1}^{m} w_i \cdot c_i(x)
$$

这里 $w_i$ 是 witness 向量中的第 $i$ 个值。

#### 目标多项式

目标多项式 $t(x)$ 定义为：

$$t(x) = \prod_{j=1}^{n} (x - r_j)$$

其中 $r_j$ 是评估点，$n$ 是约束数量。

#### 约束满足条件

如果所有约束都满足，则存在一个多项式 $h(x)$，使得：

$$A(x)B(x) - C(x) = h(x)t(x)$$

$h(x)$ 是商多项式，表明约束一致性。

### 3.4 拉格朗日插值

在 QAP 中，多项式通常使用拉格朗日基函数表示，而不是系数表示。拉格朗日基函数 $L_i(x)$ 满足：

$$L_i(r_j) = \begin{cases} 1 & \text{if } i = j \\ 0 & \text{if } i \neq j \end{cases}$$

拉格朗日基函数的定义为：

$$L_i(x) = \prod_{j=1, j \neq i}^{n} \frac{x - r_j}{r_i - r_j}$$

使用拉格朗日基函数，可以更高效地计算多项式在特定点的值。

## 4. Groth16 协议详细步骤

### 4.1 Setup 阶段

1. 选择随机值 $\tau, \alpha, \beta, \gamma, \delta \in \mathbb{F}_p$
2. 计算证明密钥：
   - $g^\tau, g^{\tau^2}, \ldots, g^{\tau^d}$
   - $g^\alpha, g^\beta, g^\delta$
   - $g^{a_i(\tau)}, g^{\beta a_i(\tau)}, h^{b_i(\tau)}, g^{c_i(\tau)}$ 对所有 $i \in [m]$
3. 计算验证密钥：
   - $g^\gamma, h^\beta, h^\gamma$
   - $e(g^\alpha, h^\beta)$
   - $h^{\tau}, h^{\tau^2}, \ldots, h^{\tau^d}$

### 4.2 Prove 阶段

1. **计算 witness 多项式**：
   - 根据 witness 向量 $w$ 计算 $A(\tau), B(\tau), C(\tau)$ 的值
   - 这些值可以表示为 $\sum_{i=1}^{m} w_i a_i(\tau), \sum_{i=1}^{m} w_i b_i(\tau), \sum_{i=1}^{m} w_i c_i(\tau)$

2. **计算 $h(x)$**：
   - 计算 $h(x)$ 使得 $A(x)B(x) - C(x) = h(x)t(x)$
   - 这一步通常通过多项式除法完成

3. **选择随机数**：
   - 选择随机数 $r, s \in \mathbb{F}_p$

4. **计算证明 $\pi$ (Proof)**：
   - $\pi_a = g^{A(\tau)} \cdot g^{r \cdot \delta}$
   - $\pi_b = h^{B(\tau)} \cdot h^{s \cdot \delta}$
   - $\pi_c = g^{C(\tau) + r \cdot A(\tau) + s \cdot B(\tau) + r \cdot s \cdot \delta}$

### 4.3 Verify 阶段

验证者接收到证明 $\pi = (\pi_a, \pi_b, \pi_c)$ 后，执行以下验证：

$$e(\pi_a, \pi_b) = e(g^\alpha, h^\beta) \cdot e(\pi_c, g^\gamma)$$

验证过程的原理：
- 验证者检查 $A(x), B(x), C(x)$ 是否满足 $h(x)t(x)$ 的约束
- 双线性配对用于高效验证，无需知道具体的 witness 值
- 验证等式利用了双线性配对的性质，将多项式关系转化为群元素的关系

## 5. Groth16 的优缺点

### 5.1 优点

- **证明大小小**：只有 3 个群元素，是最小的 zk-SNARK 证明之一
- **验证速度快**：验证只需要执行少量的配对运算，通常只需几毫秒
- **证明生成效率高**：相比其他 zk-SNARK 方案，Groth16 的证明生成过程更加高效
- **完美零知识**：在随机预言机模型下提供完美的零知识性
- **广泛应用**：已在多个实际项目中得到应用和验证，如 Zcash

### 5.2 缺点

- **需要可信设置**：需要一个可信的初始设置阶段，如果设置参数泄露，可能导致伪造证明
- **电路特定性**：每个电路需要单独的可信设置，不能通用
- **不支持通用电路更新**：如果电路发生变化，需要重新进行可信设置
- **后量子安全性不足**：基于椭圆曲线密码学，面临量子计算威胁
- **知识可靠性假设**：安全性依赖于特定的密码学假设，如知识系数假设

## 6. 实际应用案例

### 6.1 Zcash

Zcash 是一种专注于隐私保护的加密货币，在其 Sapling 升级中采用了 Groth16 协议：

- **隐私交易**：允许用户在不泄露交易金额、发送方和接收方的情况下进行交易
- **性能提升**：相比之前使用的 BCTV14 协议，Groth16 将证明生成时间从 37 秒减少到 7 秒
- **验证速度**：交易验证时间显著减少，提高了网络吞吐量
- **可信设置**：Zcash 进行了多方计算仪式（MPC）来生成可信设置参数，减少单点信任风险

### 6.2 以太坊 zkRollups

zkRollups 是以太坊的第二层扩容解决方案，使用 Groth16 来验证批量交易的有效性：

- **批量处理**：将多个交易打包在一起，生成单个证明
- **链上验证**：证明在以太坊主链上验证，保证安全性
- **吞吐量提升**：相比直接在主链上处理，可以提高交易吞吐量数百倍
- **成本降低**：减少每笔交易的 gas 成本

### 6.3 隐私保护的身份验证

Groth16 被用于构建隐私保护的身份验证系统：

- **选择性披露**：用户可以证明他们满足特定条件（如年龄大于 18 岁），而不泄露具体年龄
- **零知识 KYC**：在满足监管要求的同时保护用户隐私
- **匿名凭证**：允许用户证明他们拥有有效凭证，而不泄露凭证内容

## 7. 技术实现与优化

### 7.1 多项式评估优化

Groth16 的实现中，多项式评估是计算密集型操作：

- **快速傅里叶变换 (FFT)**：用于高效计算多项式在多个点的值
- **拉格朗日基函数**：使用拉格朗日基函数表示多项式，简化计算
- **批处理技术**：同时计算多个多项式评估，减少计算开销

### 7.2 多指数运算优化

多指数运算（MultiExp）是 Groth16 中的另一个计算瓶颈：

- **窗口方法**：使用窗口技术减少指数运算次数
- **批处理技术**：组合多个指数运算，减少总体计算量
- **并行计算**：利用多核 CPU 或 GPU 加速计算

### 7.3 可信设置优化

为了减少可信设置的风险，研究人员提出了多种优化方法：

- **多方计算 (MPC)**：多个参与者共同生成设置参数，只要有一个诚实参与者，安全性就能保证
- **可更新的设置**：允许在不重新进行完整设置的情况下更新参数
- **通用设置**：研究通用的可信设置，可用于多个电路

## 8. 与其他 zk-SNARK 协议的比较

### 8.1 Groth16 vs PGHR13

PGHR13 是早期的 zk-SNARK 协议：

- **证明大小**：Groth16 (3 个元素) < PGHR13 (7 个元素)
- **验证时间**：Groth16 更快，需要更少的配对运算
- **证明生成**：Groth16 更高效
- **安全性**：两者都需要可信设置，但 Groth16 提供更强的零知识性

### 8.2 Groth16 vs Plonk

Plonk 是一种更新的 zk-SNARK 协议：

- **证明大小**：Groth16 (3 个元素) < Plonk (约 6-8 个元素)
- **验证时间**：Groth16 略快
- **通用性**：Plonk 支持通用可信设置，一次设置可用于多个电路
- **电路更新**：Plonk 支持更灵活的电路更新，无需重新进行可信设置

### 8.3 Groth16 vs zk-STARKs

zk-STARKs 是一种不需要可信设置的零知识证明系统：

- **可信设置**：Groth16 需要，zk-STARKs 不需要
- **证明大小**：Groth16 (几百字节) << zk-STARKs (几十到几百 KB)
- **验证时间**：Groth16 更快
- **后量子安全性**：zk-STARKs 具有后量子安全性，Groth16 没有

## 9. 未来发展方向

### 9.1 减少可信设置依赖

- **通用可信设置**：开发适用于任意电路的通用可信设置
- **透明设置**：研究不需要可信设置的 zk-SNARK 变体
- **混合方法**：结合 zk-STARKs 和 zk-SNARKs 的优点

### 9.2 提高性能

- **硬件加速**：利用专用硬件（如 FPGA、ASIC）加速证明生成
- **算法优化**：改进多项式评估和多指数运算算法
- **并行计算**：更好地利用并行计算资源

### 9.3 增强安全性

- **后量子安全**：开发抵抗量子计算攻击的变体
- **形式化验证**：对协议实现进行形式化验证，确保正确性
- **减少密码学假设**：基于更标准、更少的密码学假设








