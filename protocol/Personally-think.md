在基于椭圆曲线的 ZKPs 中，验证者通过与证明者进行密码学协议来验证陈述的有效性，而无需泄露任何敏感信息。

## 椭圆曲线密码学 (ECC) 和共享点

- ECC 在 ZKPs 中起着至关重要的作用，因为它提供了安全计算和密钥生成的基本数学框架。
- 椭圆曲线由特定方程定义（如 y² = x³ + ax + b mod p），并提供群结构，其中元素可以使用称为"点加法"的操作进行组合。

### 椭圆曲线上的基本运算

- **点加法**：如果 P = (x₁, y₁) 和 Q = (x₂, y₂) 是曲线上的两点，则 P + Q = (x₃, y₃)，其中:
  - λ = (y₂ - y₁)/(x₂ - x₁) mod p （当 P ≠ Q 时）
  - λ = (3x₁² + a)/(2y₁) mod p （当 P = Q 时，即点倍乘）
  - x₃ = λ² - x₁ - x₂ mod p
  - y₃ = λ(x₁ - x₃) - y₁ mod p

- **标量乘法**：对于整数 k 和曲线上的点 P，标量乘法 kP 表示将 P 与自身相加 k 次。这是 ECC 中的基本操作，也是椭圆曲线离散对数问题的基础。

## ZK 证明验证过程

1. **设置:**
   - 证明者和验证者商定一个公共椭圆曲线、一个基点 G 和一个群阶 q。
   - 证明者生成一个秘密密钥（标量）x 并计算一个公点 Y = xG。
2. **证明生成:**
   - 证明者希望证明陈述 S，而无需透露有关 x 或 S 的任何其他信息。
   - 为此，证明者使用 x 和 S 生成证明 π，通常涉及承诺、密码哈希和签名。
3. **证明验证:**
   - 验证者从证明者接收证明 π 和公点 Y。
   - 验证者通过使用 G、Y 和 π 在椭圆曲线上执行计算来验证证明 π。
   - 如果证明有效，验证者则接受陈述 S，而无需了解有关 x 或 S 的任何信息。

### Schnorr 协议示例

以下是一个简单的 Schnorr 协议示例，展示了如何证明对离散对数的知识：

1. **设置**：公共参数为椭圆曲线 E、基点 G 和群阶 q。证明者知道 x，使得 Y = xG。
2. **证明生成**：
   - 证明者选择随机数 r ∈ [1, q-1]
   - 计算承诺 R = rG
   - 计算挑战 c = H(G, Y, R)，其中 H 是哈希函数
   - 计算响应 s = r + cx mod q
   - 发送证明 π = (R, s) 给验证者
3. **验证**：
   - 验证者计算 c = H(G, Y, R)
   - 检查 sG ?= R + cY
   - 如果等式成立，则接受证明

## 共享点计算

- 在 ZKP 验证的背景下，"共享点"并未直接参与验证过程。
- 但是，共享点概念与底层椭圆曲线群结构相关。
- 在证明生成过程中，证明者可能会执行涉及组合椭圆曲线上多个点的计算。
- 这些计算可以视为证明者和验证者之间"共享"信息，但共享点本身并不能直接确定证明的有效性。

## ZKP 验证的核心思想

- ZKP 验证的核心思想是验证者可以在不了解有关 x 或 S 的任何其他信息的情况下验证陈述 S。
- 这通过巧妙地使用椭圆曲线运算和密码学技术来实现。
- 验证者只能确认证明者拥有生成有效证明（对于真陈述）所需的知识。

## 其他说明

- 不同的 ZKP 构造可能在证明生成和验证过程中具有特定的变化。
- 在某些 ZKP 协议中，共享点概念可能更明显，但它并非所有 ZKP 的普遍特征。
- ZKP 验证的重点是确保有效性而不泄露敏感信息，而共享点计算在实现这一目标中起着支持作用。

---

## zk-SNARK 中的 FFT 域与约束关系

Zk-snark 中，电路中的约束数量和 FFT（快速傅里叶变换）域中的元素数量密切相关，但并不直接成正比。FFT 域在 Kate-Zaverucha-Goldberg (KZG) 多项式承诺方案中起着至关重要的作用，该方案用于多项式承诺和验证。

### 约束与 FFT 域元素之间的关系

1. **最小约束要求:**
   - zk-SNARK 需要一个至少包含两个元素的域来执行多项式承诺和验证。
   - 这意味着电路中的约束数量必须至少为两个。
2. **域大小和约束编码:**
   - FFT 域的大小通常由电路中的约束数量决定。
   - 约束被编码成多项式，域大小应足够大以容纳这些多项式而不会造成碰撞或信息泄漏。
3. **约束到域的映射:**
   - 约束和 FFT 域元素之间没有直接的一对一映射。
   - 映射取决于特定的 zk-SNARK 实现以及用于多项式编码和承诺的技术。
4. **域大小考虑:**
   - 域大小的选择是效率和安全性的权衡。
   - 较大的域提供了更高的安全性，但也增加了计算开销。
   - 域大小应根据应用程序的特定要求仔细选择。

### 具体数学示例

假设我们有一个简单的电路，计算 z = x² + y，包含以下约束:
1. t = x · x （中间变量，表示 x²）
2. z = t + y （最终输出）

这两个约束可以表示为多项式:
- p₁(x, t, y, z) = t - x²
- p₂(x, t, y, z) = z - t - y

在 QAP (Quadratic Arithmetic Program) 转换中，这些约束会被转换为多项式形式。如果我们有 n 个约束，我们通常需要一个大小为 2ⁿ 的 FFT 域来有效地进行多项式运算。

### 示例

考虑一个具有 5 个约束的电路。该电路的 FFT 域可能具有 16 个元素（2^4）。这意味着约束被编码成度数高达 15 的多项式，域大小足够大以防止碰撞并确保承诺方案的安全性。

在实际实现中，域大小通常是大于约束数量的最小 2 的幂，以便高效地执行 FFT 算法。

> 约束计数对于 zk-SNARK 方案的正常运行以及证明生成和验证过程的正确性至关重要。
>
> - **最小约束要求:**
>   - zk-SNARK 依赖于多项式承诺和验证，这需要一个至少包含两个元素的域。
>   - 如果电路只有一个约束，则意味着只有一个多项式需要承诺，这使得重建输入并打破零知识属性变得非常容易。
> - **实施限制:**
>   - 此代码中使用的特定 zk-SNARK 实现可能与最小约束数量相关联的其他约束或限制。
>   - 如果约束计数太低，则尽早返回错误有助于防止潜在问题并确保不会使用无效电路尝试证明生成和验证过程。

## FFT 域大小的性能与安全性平衡

FFT 域的大小需要仔细选择，以平衡效率和安全性。域大小过大，会导致数据获取和计算成本过高，降低整体性能。而域大小过小，则可能无法满足安全性要求，导致信息泄露或其他安全问题。

### 域大小对性能的影响

- **数据获取:** 域越大，需要存储和传输的数据量就越大，这可能会对带宽和存储空间造成压力，尤其是在移动设备或资源受限的场景中。
- **计算成本:** 域越大，用于多项式计算和 FFT 变换的计算量就越大，这可能会导致证明生成和验证过程更加耗时，尤其是对于资源受限的设备。

### 域大小对安全性的影响

- **碰撞概率:** 域越大，发生碰撞的概率越低，这意味着攻击者更难通过伪造证明来欺骗验证者。
- **信息泄露:** 域过小，可能会导致信息泄露，因为攻击者可能能够通过分析承诺来推断出电路的某些输入或中间值。

### 电路设计优化

为了减小域大小带来的性能影响，可以考虑以下电路设计优化策略：

- **减少约束数量:** 仔细分析电路结构，尽量减少冗余或不必要的约束。
- **选择合适的约束类型:** 使用更有效的约束类型，例如非线性约束，可以减少约束的数量，同时保持相同级别的表达能力。
- **利用代数简化:** 在电路生成过程中，应用代数简化技术可以减少多项式的复杂度，从而降低对域大小的要求。

### 实际应用中的权衡

在实际应用中，域大小的选择通常基于以下因素：
- 电路的复杂性和约束数量
- 目标平台的计算能力
- 安全性要求
- 证明生成和验证的时间要求

例如，对于一个包含 10,000 个约束的电路，可能需要一个大小为 2^14 = 16,384 的 FFT 域。这将导致多项式度数为 16,383，这对于某些应用可能是可接受的，但对于移动设备可能会导致性能问题。

---

#### Stark 中的边界约束

边界约束是指对计算轨迹（execution trace）两端的特定值的约束。这些约束通常用来定义计算的起点和终点，或者用来限制计算过程中的某些中间值。

作用：

1. **定义计算范围**：边界约束明确了计算的起始和结束位置，从而限定了计算的范围。
2. **确保计算的正确性**：边界约束可以确保计算的结果满足特定的条件，例如，计算的输出值必须等于某个预期的值。
3. **提高验证效率**：通过引入边界约束，可以减少验证者需要验证的计算步骤，从而提高验证效率。

类型：

1. **初始值约束**：对计算轨迹的第一个值的约束。
2. **最终值约束**：对计算轨迹的最后一个值的约束。
3. **中间值约束**：对计算轨迹中某些特定位置的值的约束。例如，一个排序算法的中间结果必须满足有序性。

在Stark中，边界约束通常通过多项式来表示。这些多项式会与计算轨迹中的其他多项式一起，构成一个约束系统。验证者通过验证这个约束系统是否成立，来判断计算是否正确。具体实现如下：

1. **定义边界条件**：根据具体的计算任务，定义需要满足的边界条件。
2. **构造多项式**：将边界条件转化为多项式方程。
3. **将多项式加入约束系统**：将表示边界条件的多项式加入到整个约束系统中。
4. **验证约束系统**：使用高效的算法（如FRI协议）来验证约束系统是否成立。

### 数学表示示例

假设我们有一个计算轨迹 T = [t₀, t₁, ..., tₙ]，我们可以定义以下边界约束：

1. **初始值约束**：t₀ = a，其中 a 是预定义的初始值。
   - 多项式表示：p₁(x) = t(x) - a，要求 p₁(0) = 0

2. **最终值约束**：tₙ = b，其中 b 是预期的最终值。
   - 多项式表示：p₂(x) = t(x) - b，要求 p₂(n) = 0

3. **中间值约束**：例如，要求 t₃ = c
   - 多项式表示：p₃(x) = t(x) - c，要求 p₃(3) = 0

### 斐波那契序列示例

考虑使用STARK证明斐波那契序列的计算。假设我们要证明序列 [1, 1, 2, 3, 5, 8, 13, 21] 是正确的斐波那契序列。

1. **边界约束**：
   - 初始值：t₀ = 1, t₁ = 1
   - 递推关系：tᵢ = tᵢ₋₁ + tᵢ₋₂ 对于 i ≥ 2
   - 最终值：t₇ = 21

2. **多项式表示**：
   - 初始约束：p₁(x) = t(x) - 1，要求 p₁(0) = 0 且 p₁(1) = 0
   - 递推约束：p₂(x) = t(x) - t(x-1) - t(x-2)，要求 p₂(i) = 0 对于 i ≥ 2
   - 最终约束：p₃(x) = t(x) - 21，要求 p₃(7) = 0

#### 边界约束与r1cs的区别

##### 相同点：

* **约束系统**： 两种系统都通过建立一个约束系统来描述计算。无论是Stark的边界约束还是Snark的R1CS，都是为了确保**计算过程的正确性**。
* **多项式表示**：两种系统都将约束转化为多项式方程。这些多项式方程在验证阶段需要被满足。

##### 区别：

* **约束本质**： 
  * `R1cs` 主要关注的是**计算过程中的每一步**转换是否符合预定义的规则。这些规则通常是基于算术电路的。
  * `边界约束`：更关注计算的**起点、终点以及中间过程的某些特定点**。这些约束可以是算术运算的约束，也可以是更高级别的逻辑约束。
* **验证方式**： 
  * **R1CS:** 通常采用基于**椭圆曲线密码学**的交互式或非交互式证明系统来验证。
  * **stark**：采用基于**多项式承诺和FRI协议**的**非交互式证明系统**来验证。FRI协议更关注多项式在特定点上的取值，而仅仅是多项式本身。
* **计算模型**：
  * **R1CS**： 适用于算术电路模型，将计算分解为以系列的算术运算
  * **stark**：可以支持更广泛的计算模型，包括算术电路、有限状态机等。
* **证明大小和验证时间**：
  * **R1CS:** 证明大小和验证时间通常与**电路的大小成正比**。
  * **stark**：证明大小和验证时间与**计算轨迹的长度有关**，但可以通过参数调整来平衡证明大小和验证时间。

R1CS更关注计算过程的每一步转换，而边界约束更关注计算的起点、终点和中间过程的特定点。

举个不恰当的例子就是：

- **R1CS** 就像是一个老师，时刻关注着学生在做题过程中的每一步计算是否正确。
- **边界约束** 就像是一个裁判，只关注学生是否在规定的时间内完成了题目，并且答案是否正确。

### FRI协议在STARK中的应用

FRI (Fast Reed-Solomon Interactive Oracle Proof) 协议是STARK中用于验证多项式约束的核心技术。它允许验证者高效地验证一个多项式的度数是否低于某个阈值，而无需完整读取该多项式。

#### FRI协议的基本步骤

1. **承诺阶段**：
   - 证明者将计算轨迹编码为一个低度多项式 f(x)
   - 证明者对该多项式进行承诺（通常使用Merkle树）

2. **查询阶段**：
   - 验证者随机选择一些点 x₁, x₂, ..., xₖ
   - 证明者提供这些点上的多项式值 f(x₁), f(x₂), ..., f(xₖ)
   - 证明者还提供这些值的Merkle证明

3. **度数降低**：
   - 通过一系列的折叠操作，将高度多项式逐步降为常数
   - 每次折叠都会将多项式的度数大约减半

4. **最终验证**：
   - 验证者检查最终的多项式是否为常数（或度数非常低）
   - 如果是，则接受证明；否则，拒绝证明

#### FRI协议的数学原理

FRI协议基于多项式的代数性质，特别是低度多项式的结构特性。关键步骤包括：

1. **多项式折叠**：
   对于多项式 f(x)，定义其折叠为：
   
   g(x) = (f(ωx) + f(-ωx))/2
   
   其中 ω 是域中的二次非剩余。这个操作将 f 的度数大约减半。

2. **一致性检查**：
   验证者通过检查随机点 z 上的值来验证折叠是否正确：
   
   g(z²) = (f(ωz) + f(-ωz))/2

3. **递归应用**：
   重复折叠过程，直到得到一个常数多项式。

#### 具体实现示例

假设我们有一个度数为 7 的多项式 f(x)，我们想证明它的度数确实不超过 7：

1. **第一轮折叠**：
   - 计算 g₁(x) = (f(ωx) + f(-ωx))/2
   - g₁ 的度数不超过 3

2. **第二轮折叠**：
   - 计算 g₂(x) = (g₁(ωx) + g₁(-ωx))/2
   - g₂ 的度数不超过 1

3. **第三轮折叠**：
   - 计算 g₃(x) = (g₂(ωx) + g₂(-ωx))/2
   - g₃ 应该是常数

4. **验证**：
   - 验证者检查 g₃ 是否为常数
   - 同时，验证者通过随机点检查确保每一步折叠都是正确的

#### FRI协议的优势

1. **透明性**：不需要可信设置，只依赖于密码学哈希函数
2. **后量子安全**：不依赖于椭圆曲线密码学，对量子计算攻击有更强的抵抗力
3. **可扩展性**：证明大小和验证时间随计算规模的增长较为缓慢（对数级别）

### plonkish 与 R1CS的区别

概念：

* Plonkish 是以 **Plonk** 为代表的一类零知识证明系统中的约束描述方式，广义上称为 **Arithmetic Intermediate Representation (AIR)** 或 **PLONK-like constraints**。其约束形式是基于**多项式等式**（如：范围约束/非线性运算） **使用多项式承诺来验证约束关系，能够更高效地支持更复杂的代数逻辑**。
* R1CS 则是将约束表示为一组 **秩为1的多项式约束**。

表达能力：

* R1CS ：
  * **结构化强**：强调通过线性组合来构造约束。
  * 灵活性低：仅适用于**线性约束**（乘积后相等），复杂操作（如非线性函数）需要通过手动分解转化为基本线性操作，导致电路较大。
  * **电路等价性**：R1CS 表达的每个约束直接对应电路的一个节点或操作。
* Plonkish：
  * **灵活性高**：支持任意多项式约束，无需严格限制为线性乘积。
  * **更紧凑的约束**：Plonkish 可以利用多项式分段表达复杂逻辑，减少约束总数。

工作机制：

* R1cs：
  * 将问题分解为基本线性约束，每个约束需要单独验证。
  * 使用 **QAP (Quadratic Arithmetic Program)** 将 R1CS 转化为用于证明的多项式表示。
  * 证明过程需要对每个变量及约束单独计算。
* Plonkish：
  * 使用多项式承诺系统（如 Kate 承诺）来压缩和验证约束。
  * 约束通过多项式的根性验证（即证明多项式在某些点上的值符合约束条件）
  * 可批量验证验证多个约束，效率更高。

### Plonkish约束示例

考虑一个简单的计算：z = x³ + y

1. **R1CS表示**需要引入中间变量：
   - t₁ = x · x （计算x²）
   - t₂ = t₁ · x （计算x³）
   - z = t₂ + y （最终结果）

   这需要3个约束。

2. **Plonkish表示**可以直接表达为：
   - q(x, y, z) = z - (x³ + y)
   
   只需要1个约束，大大简化了表示。

| constraints-system | R1cs                         | Plonkish                   |
| ------------------ | ---------------------------- | -------------------------- |
| 约束形式           | <a . Z> * <b.Z> = <c. Z>     | 支持任意代数的多项式形式   |
| 证明系统依赖       | QAP                          | 多项式承诺系统             |
| 效率/可扩展性      | 效率低且扩展性低             | 效率高，可扩展性高         |
| 表述方式           | 线性代数电路                 | 高阶代数                   |
| 适用系统           | groth 等传统的snark 证明系统 | plonk 为代表的新型证明系统 |









