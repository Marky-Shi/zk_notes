在基于椭圆曲线的 ZKPs 中，验证者通过与证明者进行密码学协议来验证陈述的有效性，而无需泄露任何敏感信息。

**椭圆曲线密码学 (ECC) 和共享点:**

- ECC 在 ZKPs 中起着至关重要的作用，因为它提供了安全计算和密钥生成的基本数学框架。
- 椭圆曲线由特定方程定义，并提供群结构，其中元素可以使用称为“点加法”的操作进行组合。

**ZK 证明验证过程:**

1. **设置:**
   - 证明者和验证者商定一个公共椭圆曲线、一个基点 G 和一个群阶 q。
   - 证明者生成一个秘密密钥（标量）x 并计算一个公点 Y = xG。
2. **证明生成:**
   - 证明者希望证明陈述 S，而无需透露有关 x 或 S 的任何其他信息。
   - 为此，证明者使用 x 和 S 生成证明 π，通常涉及承诺、密码哈希和签名。
3. **证明验证:**
   - 验证者从证明者接收证明 π 和公点 Y。
   - 验证者通过使用 G、Y 和 π 在椭圆曲线上执行计算来验证证明 π。
   - 如果证明有效，验证者则接受陈述 S，而无需了解有关 x 或 S 的任何信息。

**共享点计算:**

- 在 ZKP 验证的背景下，“共享点”并未直接参与验证过程。
- 但是，共享点概念与底层椭圆曲线群结构相关。
- 在证明生成过程中，证明者可能会执行涉及组合椭圆曲线上多个点的计算。
- 这些计算可以视为证明者和验证者之间“共享”信息，但共享点本身并不能直接确定证明的有效性。

**ZKP 验证的核心思想:**

- ZKP 验证的核心思想是验证者可以在不了解有关 x 或 S 的任何其他信息的情况下验证陈述 S。
- 这通过巧妙地使用椭圆曲线运算和密码学技术来实现。
- 验证者只能确认证明者拥有生成有效证明（对于真陈述）所需的知识。

**其他说明:**

- 不同的 ZKP 构造可能在证明生成和验证过程中具有特定的变化。
- 在某些 ZKP 协议中，共享点概念可能更明显，但它并非所有 ZKP 的普遍特征。
- ZKP 验证的重点是确保有效性而不泄露敏感信息，而共享点计算在实现这一目标中起着支持作用。





Zk-snark 中，电路中的约束数量和 FFT（快速傅里叶变换）域中的元素数量密切相关，但并不直接成正比。FFT 域在 Kate-Shanahan zk-SNARK 方案中起着至关重要的作用，该方案用于多项式承诺和验证。

**约束与 FFT 域元素之间的关系:**

1. **最小约束要求:**
   - zk-SNARK 需要一个至少包含两个元素的域来执行多项式承诺和验证。
   - 这意味着电路中的约束数量必须至少为两个。
2. **域大小和约束编码:**
   - FFT 域的大小通常由电路中的约束数量决定。
   - 约束被编码成多项式，域大小应足够大以容纳这些多项式而不会造成碰撞或信息泄漏。
3. **约束到域的映射:**
   - 约束和 FFT 域元素之间没有直接的一对一映射。
   - 映射取决于特定的 zk-SNARK 实现以及用于多项式编码和承诺的技术。
4. **域大小考虑:**
   - 域大小的选择是效率和安全性的权衡。
   - 较大的域提供了更高的安全性，但也增加了计算开销。
   - 域大小应根据应用程序的特定要求仔细选择。

**示例:**

考虑一个具有 5 个约束的电路。该电路的 FFT 域可能具有 16 个元素（2^4）。这意味着约束被编码成度数高达 15 的多项式，域大小足够大以防止碰撞并确保承诺方案的安全性。



> 约束计数对于 zk-SNARK 方案的正常运行以及证明生成和验证过程的正确性至关重要。
>
> - **最小约束要求:**
>   - zk-SNARK 依赖于多项式承诺和验证，这需要一个至少包含两个元素的域。
>   - 如果电路只有一个约束，则意味着只有一个多项式需要承诺，这使得重建输入并打破零知识属性变得非常容易。
> - **实施限制:**
>   - 此代码中使用的特定 zk-SNARK 实现可能与最小约束数量相关联的其他约束或限制。
>   - 如果约束计数太低，则尽早返回错误有助于防止潜在问题并确保不会使用无效电路尝试证明生成和验证过程。





FFT 域的大小需要仔细选择，以平衡效率和安全性。域大小过大，会导致数据获取和计算成本过高，降低整体性能。而域大小过小，则可能无法满足安全性要求，导致信息泄露或其他安全问题。

**域大小对性能的影响:**

- **数据获取:** 域越大，需要存储和传输的数据量就越大，这可能会对带宽和存储空间造成压力，尤其是在移动设备或资源受限的场景中。
- **计算成本:** 域越大，用于多项式计算和 FFT 变换的计算量就越大，这可能会导致证明生成和验证过程更加耗时，尤其是对于资源受限的设备。

**域大小对安全性的影响:**

- **碰撞概率:** 域越大，发生碰撞的概率越低，这意味着攻击者更难通过伪造证明来欺骗验证者。
- **信息泄露:** 域过小，可能会导致信息泄露，因为攻击者可能能够通过分析承诺来推断出电路的某些输入或中间值。

**电路设计优化:**

为了减小域大小带来的性能影响，可以考虑以下电路设计优化策略：

- **减少约束数量:** 仔细分析电路结构，尽量减少冗余或不必要的约束。
- **选择合适的约束类型:** 使用更有效的约束类型，例如非线性约束，可以减少约束的数量，同时保持相同级别的表达能力。
- **利用代数简化:** 在电路生成过程中，应用代数简化技术可以减少多项式的复杂度，从而降低对域大小的要求。



#### Stark 中的边界约束

边界约束是指对计算轨迹（execution trace）两端的特定值的约束。这些约束通常用来定义计算的起点和终点，或者用来限制计算过程中的某些中间值。

作用：

1. **定义计算范围**：边界约束明确了计算的起始和结束位置，从而限定了计算的范围。
2. **确保计算的正确性**：边界约束可以确保计算的结果满足特定的条件，例如，计算的输出值必须等于某个预期的值。
3. **提高验证效率**：通过引入边界约束，可以减少验证者需要验证的计算步骤，从而提高验证效率。

类型：

1. **初始值约束**：对计算轨迹的第一个值的约束。
2. **最终值约束**：对计算轨迹的最后一个值的约束。
3. **中间值约束**：对计算轨迹中某些特定位置的值的约束。例如，一个排序算法的中间结果必须满足有序性。

在Stark中，边界约束通常通过多项式来表示。这些多项式会与计算轨迹中的其他多项式一起，构成一个约束系统。验证者通过验证这个约束系统是否成立，来判断计算是否正确。具体实现如下：

1. **定义边界条件**：根据具体的计算任务，定义需要满足的边界条件。
2. **构造多项式**：将边界条件转化为多项式方程。
3. **将多项式加入约束系统**：将表示边界条件的多项式加入到整个约束系统中。
4. **验证约束系统**：使用高效的算法（如FRI协议）来验证约束系统是否成立。

#### 边界约束与r1cs的区别

##### 相同点：

* **约束系统**： 两种系统都通过建立一个约束系统来描述计算。无论是Stark的边界约束还是Snark的R1CS，都是为了确保**计算过程的正确性**。
* **多项式表示**：两种系统都将约束转化为多项式方程。这些多项式方程在验证阶段需要被满足。

##### 区别：

* **约束本质**： 
  * `R1cs` 主要关注的是**计算过程中的每一步**转换是否符合预定义的规则。这些规则通常是基于算术电路的。
  * `边界约束`：更关注计算的**起点、终点以及中间过程的某些特定点**。这些约束可以是算术运算的约束，也可以是更高级别的逻辑约束。
* **验证方式**： 
  * **R1CS:** 通常采用基于**椭圆曲线密码学**的交互式或非交互式证明系统来验证。
  * **stark**：采用基于**多项式承诺和FRI协议**的**非交互式证明系统**来验证。FRI协议更关注多项式在特定点上的取值，而不仅仅是多项式本身。
* **计算模型**：
  * **R1CS**： 适用于算术电路模型，将计算分解为以系列的算术运算
  * **stark**：可以支持更广泛的计算模型，包括算术电路、有限状态机等。
* **证明大小和验证时间**：
  * **R1CS:** 证明大小和验证时间通常与**电路的大小成正比**。
  * **stark**：证明大小和验证时间与**计算轨迹的长度有关**，但可以通过参数调整来平衡证明大小和验证时间。

R1CS更关注计算过程的每一步转换，而边界约束更关注计算的起点、终点和中间过程的特定点。

举个不恰当的例子就是：

- **R1CS** 就像是一个老师，时刻关注着学生在做题过程中的每一步计算是否正确。
- **边界约束** 就像是一个裁判，只关注学生是否在规定的时间内完成了题目，并且答案是否正确。



### plonkish 与 R1CS的区别

概念：

* Plonkish 是以 **Plonk** 为代表的一类零知识证明系统中的约束描述方式，广义上称为 **Arithmetic Intermediate Representation (AIR)** 或 **PLONK-like constraints**。其约束形式是基于**多项式等式**（如：范围约束/非线性运算） **使用多项式承诺来验证约束关系，能够更高效地支持更复杂的代数逻辑**。
* R1CS 则是将约束表示为一组 **秩为1的多项式约束**。

表达能力：

* R1CS ：
  * **结构化强**：强调通过线性组合来构造约束。
  * 灵活性低：仅适用于**线性约束**（乘积后相等），复杂操作（如非线性函数）需要通过手动分解转化为基本线性操作，导致电路较大。
  * **电路等价性**：R1CS 表达的每个约束直接对应电路的一个节点或操作。
* Plonkish：
  * **灵活性高**：支持任意多项式约束，无需严格限制为线性乘积。
  * **更紧凑的约束**：Plonkish 可以利用多项式分段表达复杂逻辑，减少约束总数。

工作机制：

* R1cs：
  * 将问题分解为基本线性约束，每个约束需要单独验证。
  * 使用 **QAP (Quadratic Arithmetic Program)** 将 R1CS 转化为用于证明的多项式表示。
  * 证明过程需要对每个变量及约束单独计算。
* Plonkish：
  * 使用多项式承诺系统（如 Kate 承诺）来压缩和验证约束。
  * 约束通过多项式的根性验证（即证明多项式在某些点上的值符合约束条件）
  * 可批量验证验证多个约束，效率更高。





| constraints-system | R1cs                         | Plonkish                   |
| ------------------ | ---------------------------- | -------------------------- |
| 约束形式           | <a . Z> * <b.Z> = <c. Z>     | 支持任意代数的多项式形式   |
| 证明系统依赖       | QAP                          | 多项式承诺系统             |
| 效率/可扩展性      | 效率低且扩展性低             | 效率高，可扩展性高         |
| 表述方式           | 线性代数电路                 | 高阶代数                   |
| 适用系统           | groth 等传统的snark 证明系统 | plonk 为代表的新型证明系统 |









