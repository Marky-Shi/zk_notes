# Polynomials in STARK

STARK (Scalable Transparent ARgument of Knowledge) 协议中使用多种多项式来表示计算和约束。本笔记详细介绍这些多项式的类型、作用及其在协议中的应用。

## 1. 基本多项式类型

### 1.1 轨迹多项式 (Trace Polynomial)

**作用:** 表示整个计算过程。

**形式:** 一个多项式 $T(x)$，其系数对应于计算过程中的每一步的值。

**目的:** 将计算过程转化为数学对象，方便进行多项式运算和验证。

**数学表示:**
对于计算轨迹 $[s_0, s_1, s_2, ..., s_{n-1}]$，轨迹多项式为：
$$T(x) = \sum_{i=0}^{n-1} s_i L_i(x)$$

其中 $L_i(x)$ 是拉格朗日基多项式，满足 $L_i(ω^j) = 1$ 当 $i=j$ 时，否则为0。$ω$ 是单位根。

### 1.2 边界多项式 (Boundary Polynomial)

**作用:** 描述计算的边界条件。

**目的:**
- **定义计算范围:** 确定计算的起点和终点。
- **确保计算正确性:** 约束计算结果必须满足特定的条件。

**实现方式:** 通常是一个或多个多项式，用来表示计算轨迹的初始状态、最终状态以及中间状态的约束条件。

**数学表示:**
对于初始值约束 $s_0 = a$，边界多项式为：
$$B_0(x) = T(x) - a$$
要求 $B_0(ω^0) = 0$

对于最终值约束 $s_{n-1} = b$，边界多项式为：
$$B_1(x) = T(x) - b$$
要求 $B_1(ω^{n-1}) = 0$

### 1.3 转移多项式 (Transition Constraint Polynomial)

**作用:** 描述计算过程中相邻步骤之间关系的多项式。

**目的:**
- **保证计算的连续性:** 确保计算的每一步都是按照正确的逻辑进行的，没有跳跃或错误。
- **捕捉计算错误:** 如果计算过程中出现了错误，转移多项式就会无法满足，从而被检测出来。

**实现方式:** 根据计算的每一步所涉及的变量和运算关系，来构造相应的多项式。

**数学表示:**
对于转移关系 $s_{i+1} = f(s_i)$，转移多项式为：
$$P(x) = T(ωx) - f(T(x))$$
要求对于所有 $i \in \{0, 1, ..., n-2\}$，$P(ω^i) = 0$

### 1.4 复合多项式 (Composition Polynomial)

**作用:** 将多个多项式组合成一个新的多项式。

**目的:**
- **简化验证:** 通过将多个约束合并为一个多项式，可以减少验证过程中需要处理的多项式数量，提高验证效率。
- **增强安全性:** 复合多项式可以增加攻击者分析的难度，提高系统的安全性。

**实现方式:** 通常通过多项式乘法或加法来实现。

**数学表示:**
对于多个约束多项式 $C_1(x), C_2(x), ..., C_k(x)$，复合多项式可以表示为：
$$C(x) = \sum_{i=1}^k r_i \cdot C_i(x)$$
其中 $r_i$ 是随机系数，用于混合不同的约束。

### 1.5 深度复合多项式 (Deep Composition Polynomial)

**作用:** 多层复合多项式，用于表示更复杂的约束关系。

**目的:**
- **表达复杂逻辑:** 可以表示更复杂的计算逻辑，例如递归算法、循环等。
- **提高系统表达能力:** 增强系统对不同类型计算的适应性。

**实现方式:** 通过多次复合多项式来实现。

**数学表示:**
对于复合多项式 $C(x)$ 和函数 $g$，深度复合多项式可以表示为：
$$D(x) = g(C(x))$$
或者递归地定义：
$$D_0(x) = C(x), D_{i+1}(x) = g_i(D_i(x))$$

## 2. 多项式之间的关系与作用

- **轨迹多项式** 是计算过程的整体表示。
- **边界多项式** 和 **转移多项式** 共同定义了计算的约束条件。
- **复合多项式** 可以将多个边界多项式和转移多项式组合起来，形成一个更复杂的约束多项式。
- **深度复合多项式** 是复合多项式的扩展，通过多次复合来表达更复杂的约束关系。

## 3. 在STARK协议中的应用

### 3.1 多项式承诺

在STARK中，证明者需要对轨迹多项式进行承诺，通常使用Merkle树来实现。证明者将轨迹多项式的评估值放入Merkle树的叶子节点，然后将Merkle根作为承诺发送给验证者。

### 3.2 约束验证

验证者通过检查以下条件来验证计算的正确性：
1. 边界约束：确保计算的起点和终点满足预定义的条件
2. 转移约束：确保计算的每一步都遵循正确的逻辑

这些验证通过检查相应多项式在特定点上的值是否为零来实现。

### 3.3 FRI协议与多项式

STARK使用FRI (Fast Reed-Solomon Interactive Oracle Proof) 协议来验证多项式的度数约束。FRI协议允许验证者高效地验证一个多项式的度数是否低于某个阈值，而无需完整读取该多项式。

FRI协议的基本步骤：
1. 证明者将复合多项式分解为更小的多项式
2. 通过一系列的折叠操作，将高度多项式逐步降为常数
3. 验证者通过随机抽样来验证折叠过程的正确性

## 4. 具体例子：斐波那契序列

考虑使用STARK证明斐波那契序列的计算：

1. **轨迹多项式**：表示斐波那契序列 $[1, 1, 2, 3, 5, 8, 13, 21]$
   $$T(x) = \sum_{i=0}^7 F_i L_i(x)$$
   其中 $F_i$ 是斐波那契数列的第 $i$ 个值。

2. **边界多项式**：
   - 初始值约束：$B_0(x) = T(x) - 1$，要求 $B_0(ω^0) = 0$ 且 $B_0(ω^1) = 0$
   - 最终值约束：$B_1(x) = T(x) - 21$，要求 $B_1(ω^7) = 0$

3. **转移多项式**：
   - 递推关系：$P(x) = T(ω^2x) - T(ωx) - T(x)$
   - 要求对于 $i \in \{0, 1, ..., 5\}$，$P(ω^i) = 0$

4. **复合多项式**：
   $$C(x) = r_0 \cdot B_0(x) + r_1 \cdot B_1(x) + r_2 \cdot P(x)$$
   其中 $r_0, r_1, r_2$ 是随机系数。

## 5. 类比理解

- **轨迹多项式** 是整个流水线的记录，记录了产品在每个阶段的状态。
- **边界多项式** 就像流水线的起点和终点，规定了产品应该是什么样子。
- **转移多项式** 就像流水线上的每个工序，规定了产品在每个工序中的变化。
- **复合多项式** 就像将多个工序组合起来，形成一个完整的生产流程。
- **深度复合多项式** 就像在一个生产线上，又嵌套了另一个更小的生产线。

## 6. STARK的优势

STARK使用多项式来表示计算和约束的方法具有以下优势：

1. **透明性**：不需要可信设置，只依赖于密码学哈希函数
2. **可扩展性**：证明大小和验证时间随计算规模的增长较为缓慢（对数级别）
3. **后量子安全**：不依赖于椭圆曲线密码学，对量子计算攻击有更强的抵抗力
4. **表达能力**：可以表示各种复杂的计算逻辑