# `Risc0`example project

详细的[日志](https://github.com/Marky-Shi/risc0-code/blob/main/hello/run.log)可以查看

Example

```shell
total 176
-rw-r--r--  1 scc  staff  53794 May  5 12:00 Cargo.lock
-rw-r--r--  1 scc  staff    216 May  5 11:59 Cargo.toml
-rw-r--r--  1 scc  staff  11357 May  5 11:59 LICENSE
-rw-r--r--  1 scc  staff   4399 May  5 11:59 README.md
drwxr-xr-x  4 scc  staff    128 May  5 11:59 host
drwxr-xr-x  6 scc  staff    192 May 25 10:19 methods
-rw-r--r--  1 scc  staff     88 May  5 11:59 rust-toolchain.toml
```

简单理解为`methods` 下是可自定义的程序，实际的执行也是将这部分程序编译为ELF文件。

`host` 则是验证逻辑，prover 检查并证明ELF的有效性，并输出`receipt`

```rust
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    GUEST_CODE_FOR_ZK_PROOF_ELF, GUEST_CODE_FOR_ZK_PROOF_ID
};
use risc0_zkvm::{default_prover, ExecutorEnv};

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let input: u32 = 15 * u32::pow(2, 27) + 1;
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Produce a receipt by proving the specified ELF binary.
    let receipt = prover
        .prove(env, GUEST_CODE_FOR_ZK_PROOF_ELF)
        .unwrap();

    // TODO: Implement code for retrieving receipt journal here.

    // For example:
    let output: u32 = receipt.journal.decode().unwrap();

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt
        .verify(GUEST_CODE_FOR_ZK_PROOF_ID)
        .unwrap();
  
		assert_eq!(input,output);
    println!("Hello, world! I generated a proof of guest execution! {} is a public output from journal", output);
}
```

> 设置一个PI，在自定义的程序中output = PI。



## Local prove

在之前的笔记中也大致介绍过了，risc0 proof的生成，验证分为三种方式： remote，dev-mode，local。**本节中以local为例进行分析**。

```rust
//zkvm/src/host/client/prove/mod.rs
pub fn default_prover() -> Rc<dyn Prover> {
    let explicit = std::env::var("RISC0_PROVER").unwrap_or_default();
    if !explicit.is_empty() {
        return match explicit.to_lowercase().as_str() {
            "bonsai" => Rc::new(BonsaiProver::new("bonsai")),
            "ipc" => Rc::new(ExternalProver::new("ipc", get_r0vm_path())),
            #[cfg(feature = "prove")]
            "local" => Rc::new(self::local::LocalProver::new("local")),
            _ => unimplemented!("Unsupported prover: {explicit}"),
        };
    }

    if !is_dev_mode()
        && std::env::var("BONSAI_API_URL").is_ok()
        && std::env::var("BONSAI_API_KEY").is_ok()
    {
        return Rc::new(BonsaiProver::new("bonsai"));
    }

    if cfg!(feature = "prove") {
        #[cfg(feature = "prove")]
        return Rc::new(self::local::LocalProver::new("local"));
    }

    Rc::new(ExternalProver::new("ipc", get_r0vm_path()))
}
```

根据不同的配置启动不同的prove service：

* `bonsai`  `BONSAI_API_KEY`   `BONSAI_API_URL` 是很必须设置的。
* `ipc`  [ExternalProver] 证明使用 `r0vm` 子进程。注意：必须安装`r0vm`。要指定“r0vm”的路径，请使用“RISC0_SERVER_PATH”
* `local` 本地的prover 需要启用 prove features

运行日志：

```shell
2024-05-27T06:47:27.122928Z  INFO executor: risc0_zkvm::host::server::exec::executor: execution time: 1.8ms
2024-05-27T06:47:27.122954Z  INFO executor: risc0_zkvm::host::server::session: number of segments: 1
2024-05-27T06:47:27.122957Z  INFO executor: risc0_zkvm::host::server::session: total cycles: 131072
2024-05-27T06:47:27.122958Z  INFO executor: risc0_zkvm::host::server::session: user cycles: 13368
2024-05-27T06:47:27.122960Z  INFO executor: risc0_zkvm::host::server::session: cycle efficiency: 10%
2024-05-27T06:47:27.122964Z  INFO risc0_zkvm::host::server::prove::prover_impl: prove_session: cpu, exit_code = Halted(0), journal = Some("2f0000008e64617c59a3e29953fe4d5bcbda0a28b7ba17094c117957737188921cc6226a")

```

从上述日志中可以看出local prove的生成，底层实际执行的是`prove_session`



```rust
risc0/risc0/zkvm/src/host/client/prove/mod.rs
/// Prove zkVM execution starting from the specified ELF binary.
    fn prove(&self, env: ExecutorEnv<'_>, elf: &[u8]) -> Result<Receipt> {
        self.prove_with_ctx(
            env,
            &VerifierContext::default(),
            elf,
            &ProverOpts::default(),
        )
    }
```

local prove 的核心

```rust
fn prove_session(&self, ctx: &VerifierContext, session: &Session) -> Result<ProveInfo> {
  
  // 1 generate segment proof
  let mut segments = Vec::new();
        for segment_ref in session.segments.iter() {
            let segment = segment_ref.resolve()?;
            for hook in &session.hooks {
                hook.on_pre_prove_segment(&segment);
            }
            segments.push(self.prove_segment(ctx, &segment)?);
            for hook in &session.hooks {
                hook.on_post_prove_segment(&segment);
            }
  
  //2 session_assumption_receipts
   let (assumptions, session_assumption_receipts) = session
            .assumptions
            .iter()
            .cloned()
            .unzip::<_, _, Vec<_>, Vec<_>>();
          
   let last_segment = segments.last_mut().ok_or(anyhow!("session is empty"))?;
        last_segment
            .claim
            .output
            .merge_with(
                &session
                    .journal
                    .as_ref()
                    .map(|journal| Output {
                        journal: MaybePruned::Pruned(journal.digest()),
                        assumptions: assumptions.into(),
                    })
                    .into(),
            )
            .context("failed to merge output into final segment claim")?;
          
  // 3 generate CompositeReceipt
  let composite_receipt = CompositeReceipt {
            segments,
            assumption_receipts,
            verifier_parameters,
        };
	
  composite_receipt.verify_integrity_with_context(ctx)?;

	// 4 Compress the receipt to the requested level.
   let receipt = match self.opts.receipt_kind {
            ReceiptKind::Composite => Receipt::new(
                InnerReceipt::Composite(composite_receipt),
                session.journal.clone().unwrap_or_default().bytes,
            ),
            ReceiptKind::Succinct => {
                let succinct_receipt = self.composite_to_succinct(&composite_receipt)?;
                Receipt::new(
                    InnerReceipt::Succinct(succinct_receipt),
                    session.journal.clone().unwrap_or_default().bytes,
                )
            }
            ReceiptKind::Groth16 => {
                let succinct_receipt = self.composite_to_succinct(&composite_receipt)?;
                let groth16_receipt = self.succinct_to_groth16(&succinct_receipt)?;
                Receipt::new(
                    InnerReceipt::Groth16(groth16_receipt),
                    session.journal.clone().unwrap_or_default().bytes,
                )
            }
         };
   receipt.verify_integrity_with_context(ctx)?;
  	
}
```

大致分为以下几步：

* `segment` ： 迭代session中的每个segments，调用hook `hook.on_pre_prove_segment(&segment);`  然后调用 `prove_segment` 方法生成证明，最后再次调用所有的钩子函数的 `on_post_prove_segment` 方法。**这个过程实现了对会话中每个段落的独立证明。**
  * 生成证明的过程和以往的zk-snark 又不太一样，详情请见思维导图。

* `Assumption` ：函数接下来处理 `session` 中的所有假设。它首先将假设和假设收据分离，然后将包括日志摘要和假设在内的输出合并到最后一个段落中。**这个过程实现了对session中所有假设的处理和证明。**
* `composite_receipt`:  聚合分段证明，函数检查收据的完整性`verify_integrity_with_context(ctx)?` ，并确保收据的声明与 `session` 的声明匹配。**这个过程实现了对session proof的完整性检查。**
* `Compress the receipt` : 收据压缩为 `Composite`、`Succinct` 或 `Groth16` 类型，然后再次检查收据的完整性，并确保收据的声明与 `session` 的声明匹配。**这个过程实现了对session证明的压缩和再次完整性检查**。



## Verify 

```rust
pub fn verify(&self, image_id: impl Into<Digest>) -> Result<(), VerificationError> {
        self.verify_with_context(&VerifierContext::default(), image_id)
    }
```



```rust
pub fn verify_with_context(
        &self,
        ctx: &VerifierContext,
        image_id: impl Into<Digest>,
    ) -> Result<(), VerificationError> {
        if self.inner.verifier_parameters() != self.metadata.verifier_parameters {
            return Err(VerificationError::VerifierParametersMismatch {
                expected: self.inner.verifier_parameters(),
                received: self.metadata.verifier_parameters,
            });
        }

        tracing::debug!("Receipt::verify_with_context");
        self.inner.verify_integrity_with_context(ctx)?;

        let expected_claim = ReceiptClaim::ok(image_id, MaybePruned::Pruned(self.journal.digest()));
        if expected_claim.digest() != self.inner.claim()?.digest() {
            tracing::debug!(
                "receipt claim does not match expected claim:\nreceipt: {:#?}\nexpected: {:#?}",
                self.inner.claim()?,
                expected_claim
            );
            return Err(VerificationError::ClaimDigestMismatch {
                expected: expected_claim.digest(),
                received: self.claim()?.digest(),
            });
        }

        Ok(())
    }
```

* 验证参数： 它比较内部验证器参数和元数据中的验证器参数是否匹配，如果不匹配则返回错误。
* 验证完整性： `self.inner.verify_integrity_with_context(ctx)?;`
* 检查声明：检查验证的收据上的声明是否与预期的匹配。

`verify_integrity_with_context`  验证收据的完整性和assumption的正确性

```rust
pub fn verify_integrity_with_context(
        &self,
        ctx: &VerifierContext,
    ) -> Result<(), VerificationError> {
      
      // do something
      ......
      // 连续性验证
      for receipt in receipts {
            receipt.verify_integrity_with_context(ctx)?;
            tracing::debug!("claim: {:#?}", receipt.claim);
            if let Some(id) = expected_pre_state_digest {
                if id != receipt.claim.pre.digest::<sha::Impl>() {
                    return Err(VerificationError::ImageVerificationError);
                }
            }
            if receipt.claim.exit_code != ExitCode::SystemSplit {
                return Err(VerificationError::UnexpectedExitCode);
            }
            if !receipt.claim.output.is_none() {
                return Err(VerificationError::ReceiptFormatError);
            }
            expected_pre_state_digest = Some(
                receipt
                    .claim
                    .post
                    .as_value()
                    .map_err(|_| VerificationError::ReceiptFormatError)?
                    .digest::<sha::Impl>(),
            );
        }
      
      // 完整性验证
      final_receipt.verify_integrity_with_context(ctx)?;
        tracing::debug!("final: {:#?}", final_receipt.claim);
        if let Some(id) = expected_pre_state_digest {
            if id != final_receipt.claim.pre.digest::<sha::Impl>() {
                return Err(VerificationError::ImageVerificationError);
            }
        }
      
      // 验证所有的假设
      for (assumption, receipt) in assumptions.into_iter().zip(self.assumption_receipts.iter()) {
            let assumption_ctx = match assumption.control_root {
                // If the control root is all zeroes, we should use the same verifier paramters.
                Digest::ZERO => None,
                // Otherwise, we should verify the assumption receipt using the guest-provided root.
                control_root => Some(
                    VerifierContext::empty()
                        .with_suites(ctx.suites.clone())
                        .with_succinct_verifier_parameters(SuccinctReceiptVerifierParameters {
                            control_root,
                            inner_control_root: None,
                            proof_system_info: PROOF_SYSTEM_INFO,
                            circuit_info: CircuitImpl::CIRCUIT_INFO,
                        }),
                ),
            };
            tracing::debug!("verifying assumption: {assumption:?}");
            receipt.verify_integrity_with_context(assumption_ctx.as_ref().unwrap_or(ctx))?;
            if receipt.claim_digest()? != assumption.claim {
                tracing::debug!(
                    "verifying assumption failed due to claim mismatch: assumption: {assumption:?}, receipt claim digest: {}",
                    receipt.claim_digest()?
                );
                return Err(VerificationError::ClaimDigestMismatch {
                    expected: assumption.claim,
                    received: receipt.claim_digest()?,
                });
            }
        }
      
      
}
```

* 验证连续性：通过按顺序验证每个段收据来验证连续性。
* 验证每个段及其链接到下一个段：对于收据中的每个段，都会进行完整性验证，并检查其预状态摘要是否与预期的一致。如果不一致，将返回一个 ImageVerificationError 错误。此外，还会检查退出代码是否为 SystemSplit，并确认没有输出。
* 验证最后一个收据：验证连续性中的最后一个收据，并检查其预状态摘要是否与预期的一致。
* 验证所有假设：验证收据上的所有假设是否由附加的收据解决。确保每个假设都有一个收据。如果假设的数量与假设收据的数量不匹配，将返回一个 ReceiptFormatError 错误。对于每个假设和收据，都会进行完整性验证，并检查其声明摘要是否与假设的一致。如果不一致，将返回一个 ClaimDigestMismatch 错误。



## compress

将recipt 压缩

```rust
fn compress(&self, opts: &ProverOpts, receipt: &Receipt) -> Result<Receipt> {
        match &receipt.inner {
            InnerReceipt::Composite(inner) => match opts.receipt_kind {
                ReceiptKind::Composite => Ok(receipt.clone()),
                ReceiptKind::Succinct => {
                    let succinct_receipt = self.composite_to_succinct(inner)?;
                    Ok(Receipt::new(
                        InnerReceipt::Succinct(succinct_receipt),
                        receipt.journal.bytes.clone(),
                    ))
                }
                ReceiptKind::Groth16 => {
                    let succinct_receipt = self.composite_to_succinct(inner)?;
                    let groth16_receipt = self.succinct_to_groth16(&succinct_receipt)?;
                    Ok(Receipt::new(
                        InnerReceipt::Groth16(groth16_receipt),
                        receipt.journal.bytes.clone(),
                    ))
                }
            },
            InnerReceipt::Succinct(inner) => match opts.receipt_kind {
                ReceiptKind::Composite | ReceiptKind::Succinct => Ok(receipt.clone()),
                ReceiptKind::Groth16 => {
                    let groth16_receipt = self.succinct_to_groth16(inner)?;
                    Ok(Receipt::new(
                        InnerReceipt::Groth16(groth16_receipt),
                        receipt.journal.bytes.clone(),
                    ))
                }
            },
            InnerReceipt::Groth16(_) => match opts.receipt_kind {
                ReceiptKind::Composite | ReceiptKind::Succinct | ReceiptKind::Groth16 => {
                    Ok(receipt.clone())
                }
            },
            InnerReceipt::Fake(_) => {
                ensure!(
                    is_dev_mode(),
                    "dev mode must be enabled to compress fake receipts"
                );
                Ok(receipt.clone())
            }
        }
    }
```

TIP：压缩为groth16 的时候一定要注意，必须在x86架构的cpu上，且必须安装有docker。



![risc0-local-prover](./Risc0-local-prover.png)



## Bonsai prove

```rust
fn prove_with_ctx(
        &self,
        env: ExecutorEnv<'_>,
        ctx: &VerifierContext,
        elf: &[u8],
        opts: &ProverOpts,
    ) -> Result<ProveInfo> {
      
      // initliaze  client and upload images elf files && PI
      client.upload_img(&image_id_hex, elf.to_vec())?;
      let input_id = client.upload_input(env.input)?;
      
      //upload receipts
      for assumption in &env.assumptions.borrow().cached {
            let serialized_receipt = match assumption {
                crate::AssumptionReceipt::Proven(receipt) => bincode::serialize(receipt)?,
                crate::AssumptionReceipt::Unresolved(_) => {
                    bail!("only proven assumptions can be uploaded to Bonsai.")
                }
            };
            let receipt_id = client.upload_receipt(serialized_receipt)?;
            receipts_ids.push(receipt_id);
        }
      
      //generate proof and download receipt
      let succinct_prove_info = loop{
        ... do something ...	
        if res.status == "SUCCEEDED" {
                // Download the receipt, containing the output
                let receipt_url = res
                    .receipt_url
                    .ok_or(anyhow!("API error, missing receipt on completed session"))?;

                let stats = res
                    .stats
                    .context("Missing stats object on Bonsai status res")?;
                tracing::debug!(
                    "Bonsai usage: cycles: {} total_cycles: {}",
                    stats.cycles,
                    stats.total_cycles
                );

                let receipt_buf = client.download(&receipt_url)?;
                let receipt: Receipt = bincode::deserialize(&receipt_buf)?;

                if opts.prove_guest_errors {
                    receipt.verify_integrity_with_context(ctx)?;
                } else {
                    receipt.verify_with_context(ctx, image_id)?;
                }
                break ProveInfo {
                    receipt,
                    stats: crate::SessionStats {
                        segments: stats.segments,
                        total_cycles: stats.total_cycles,
                        user_cycles: stats.cycles,
                    },
                };
      };
      
      // return receipt  
      match opts.receipt_kind {
            // If the caller requested a composite or succinct receipt, we are done.
            ReceiptKind::Composite | ReceiptKind::Succinct => {
                return Ok(succinct_prove_info);
            }
            // If they requested a groth16 receipts, we need to continue.
            ReceiptKind::Groth16 => {}
        }
        
      	// if need groth16 carate snark proof
        let snark_session = client.create_snark(session.uuid)?;
        let snark_receipt = loop {
        	"SUCCEEDED" => {
                    break res.output.with_context(|| {
                        format!(
                            "Bonsai prover workflow [{}] reported success, but provided no receipt",
                            snark_session.uuid
                        )
                    })?;
        };
          
       //verify groth16 receipt
       let groth16_receipt = Receipt::new(
            InnerReceipt::Groth16(Groth16Receipt {
                seal: snark_receipt.snark.to_vec(),
                claim: succinct_prove_info.receipt.claim()?,
                verifier_parameters: ctx.groth16_verifier_parameters.digest(),
            }),
            succinct_prove_info.receipt.journal.bytes,
        );
        groth16_receipt
            .verify_integrity_with_context(ctx)
            .context("failed to verify Groth16Receipt returned by Bonsai")?;
          
        Ok(ProveInfo {
            receipt: groth16_receipt,
            stats: succinct_prove_info.stats,
        })
        
}
```

该函数是一个用于在Bonsai prover上进行证明过程的函数。它通过上传ELF二进制文件、输入数据、收据以及与Bonsai prover进行交互来完成证明的生成和验证。
